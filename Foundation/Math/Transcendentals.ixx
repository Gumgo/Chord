export module Chord.Foundation:Math.Transcendentals;

import std;

import :Core;
import :Math.CommonMath;
import :Math.Simd;
import :Utilities.Bounds;

export import :Math.Fmod;

namespace Chord
{
  export
  {
    constexpr auto SinPi(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto CosPi(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto TanPi(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto SincPi(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Asin(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Acos(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Atan(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    template<floating_point_scalar_or_vector T>
    constexpr T Atan2(const T& y, const T& x)
    {
      // !!!
    }

    constexpr auto Exp2(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Exp10(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Exp(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Log2(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Log10(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    constexpr auto Log(const floating_point_scalar_or_vector auto& v) -> decltype(v)
    {
      // !!!
    }

    template<floating_point_scalar_or_vector T>
    constexpr T Exp2(const T& a, const T& b)
    {
      // !!!
    }
  }
}